#!/usr/bin/env python3

import json
import sys
import os
import argparse
import requests
import datetime
from time import sleep
from influxdb import line_protocol
from Crypto.Cipher import AES

FORMAT_JSON = 'json'
FORMAT_INFLUXDB = 'influxdb'
FORMAT_RAW = 'raw'

OUTPUT_FORMATS = [FORMAT_JSON, FORMAT_INFLUXDB, FORMAT_RAW]

DEFAULT_HOSTNAME = '192.168.12.6'
DEFAULT_PORT = 80
DEFAULT_PROTOCOL = 'http'
DEFAULT_KEY = 'cdc0cac1280b516e674f0057e4929bca84447cca8425007e33a88a5cf598a190'
STATUS_ROUTE = '/data/Status.json'

HTTP_TIMEOUT = 30
MAX_RETRIES = 3
RETRY_WAIT = 3

MEASUREMENT_NAME = "smart4_vdsl_status"
REPORT_FIELDS = ['days_online',
                 'device_name',
                 'dsl_downstream',
                 'dsl_link_status',
                 'dsl_upstream',
                 'ex5g_freq_5g',
                 'ex5g_freq_lte',
                 'ex5g_signal_5g',
                 'ex5g_signal_lte',
                 'inet_download',
                 'inet_upload',
                 'inet_uptime',
                 'onlinestatus',
                 'router_state']

# Fields are strings by default. Cast these to integers and optionally divide by 1,000:
BPS_FIELD = ['dsl_downstream', 'dsl_upstream', 'inet_download', 'inet_upload']

INTEGER_FIELD = ['days_online']

FLOAT_FIELD = ['ex5g_signal_5g',
               'ex5g_signal_lte']


def http_get_encrypted_json(encryptionKey, url, params={}):
    res = None
    error_msg = None

    for i in range(MAX_RETRIES + 1):
        try:
            headers = {'Accept': 'application/json'}
            response = requests.get(url, params=
            params, headers=headers, timeout=HTTP_TIMEOUT, verify=False)

            try:
                res = response.json()
            except ValueError:
                try:
                    decrypted = decrypt_response(encryptionKey, response.text)
                    res = json.loads(decrypted)
                except ValueError as e:
                    error_msg = "Decryption or JSON parsing failed: %s" % e
                    eprint(error_msg)
                    continue

        except Exception as e:
            error_msg = "Error: %s" % e
            eprint(error_msg)
            if i < MAX_RETRIES:
                eprint("Will do %i. retry in %i sec(s)..." % (i + 1, RETRY_WAIT))
                sleep(RETRY_WAIT)
            else:
                eprint("Maximum number of retries exceeded, giving up")
            continue
        break

    return res, error_msg


def decrypt_response(keyHex, data):
    # thanks to https://stackoverflow.com/a/69054338/1387396

    key = bytes.fromhex(keyHex)
    nonce = bytes.fromhex(keyHex)[:8]

    ciphertextTag = bytes.fromhex(data)
    ciphertext = ciphertextTag[:-16]
    tag = ciphertextTag[-16:]

    cipher = AES.new(key, AES.MODE_CCM, nonce)
    decrypted = cipher.decrypt_and_verify(ciphertext, tag)
    return decrypted.decode('utf-8')


def get_field(report, name, divide_by_thousand=False):
    field = next((x for x in report if x['varid'] == name), None)
    if name in BPS_FIELD:
        value = int(field['varvalue'])
        if divide_by_thousand:
            return int(value / 1000)
        return value
    if name in INTEGER_FIELD:
        return int(field['varvalue'])
    if name in FLOAT_FIELD:
        return float(field['varvalue'])
    return field['varvalue']


def get_vdsl_status(hostname, protocol, port, key, raw=False, divide_by_thousand=False, return_error=False):
    url = "%s://%s:%i%s" % (protocol, hostname, port, STATUS_ROUTE)
    report, error_msg = http_get_encrypted_json(key, url)

    if not report:
        eprint("Failed to get status from %s" % url)
        if return_error:
            if raw:
                return ''
            else:
                return {"error": 1, "error_msg": error_msg}
        return None

    if raw: return report

    status = {}
    for field in REPORT_FIELDS:
        status[field] = get_field(report, field, divide_by_thousand)
    return status


def get_data_points(vdsl_status):
    data = {"points": []}
    time = get_current_utc_time()

    data["points"].append({
        "measurement": MEASUREMENT_NAME,
        "fields": vdsl_status,
        "time": time
    })
    return data


def get_formatted_output(status, format):
    if (format == FORMAT_INFLUXDB):
        return line_protocol.make_lines(get_data_points(status))
    elif (format in [FORMAT_JSON, FORMAT_RAW]):
        return json.dumps(status)
    else:
        eprint("Unknown format %s" % format)
        return ''


def get_current_utc_time():
    return datetime.datetime.utcnow().replace(microsecond=0).isoformat()


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--SPEEDPORT_HOSTNAME", default=DEFAULT_HOSTNAME,
                        help="Specify hostname or IP address (defaults to %s)" % DEFAULT_HOSTNAME)
    parser.add_argument("--SPEEDPORT_PROTOCOL", default=DEFAULT_PROTOCOL,
                        help="Specify protocol (defaults to %s" % DEFAULT_PROTOCOL)
    parser.add_argument("--SPEEDPORT_PORT", default=DEFAULT_PORT, type=int,
                        help="Specify port (defaults to %i" % DEFAULT_PORT)
    parser.add_argument("--SPEEDPORT_KEY", default=DEFAULT_KEY,
                        help="Specify key for AES decryption (defaults to %s)" % DEFAULT_KEY)

    params = parser.parse_args()

    status = get_vdsl_status(params.SPEEDPORT_HOSTNAME, params.SPEEDPORT_PROTOCOL, params.SPEEDPORT_PORT,
                             params.SPEEDPORT_KEY)

    if not status: exit(1)

    print(get_formatted_output(status, FORMAT_JSON))


if __name__ == '__main__':
    main()
